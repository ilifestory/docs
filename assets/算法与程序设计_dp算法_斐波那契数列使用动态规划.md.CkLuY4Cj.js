import{_ as s,c as n,o as a,a4 as l,eN as p,eO as e}from"./chunks/framework.CCJHkvW2.js";const m=JSON.parse('{"title":"斐波那契数列使用动态规划","description":"","frontmatter":{},"headers":[],"relativePath":"算法与程序设计/dp算法/斐波那契数列使用动态规划.md","filePath":"算法与程序设计/dp算法/斐波那契数列使用动态规划.md","lastUpdated":1708482714000}'),o={name:"算法与程序设计/dp算法/斐波那契数列使用动态规划.md"},t=l('<h1 id="斐波那契数列使用动态规划" tabindex="-1">斐波那契数列使用动态规划 <a class="header-anchor" href="#斐波那契数列使用动态规划" aria-label="Permalink to &quot;斐波那契数列使用动态规划&quot;">​</a></h1><p><img src="'+p+`" alt="An image"></p><h2 id="斐波那契数列——递归实现-python语言-——自顶向下" tabindex="-1">斐波那契数列——递归实现（python语言）——自顶向下 <a class="header-anchor" href="#斐波那契数列——递归实现-python语言-——自顶向下" aria-label="Permalink to &quot;斐波那契数列——递归实现（python语言）——自顶向下&quot;">​</a></h2><p>递归调用是非常耗费内存的，程序虽然简洁可是算法复杂度为○(2ⁿ)，当n很大时，程序运行很慢，甚至内存爆满。</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">def</span><span style="color:#C3E88D;"> fib</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">n</span><span style="color:#89DDFF;">)</span><span style="color:#C3E88D;">:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    #终止条件，也就是递归出口</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">    if</span><span style="color:#FFCB6B;"> n</span><span style="color:#C3E88D;"> ==</span><span style="color:#F78C6C;"> 0</span><span style="color:#C3E88D;"> or</span><span style="color:#C3E88D;"> n</span><span style="color:#C3E88D;"> ==</span><span style="color:#C3E88D;"> 1:</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">        return</span><span style="color:#F78C6C;"> 1</span></span>
<span class="line"><span style="color:#BABED8;">    else:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">        #递归条件</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">        return</span><span style="color:#BABED8;"> (fib(n-1) + fib(</span><span style="color:#FFCB6B;">n</span><span style="color:#C3E88D;"> -</span><span style="color:#F78C6C;"> 2</span><span style="color:#BABED8;">))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="斐波那契数列——动态规划实现-python语言-——自底向上" tabindex="-1">斐波那契数列——动态规划实现（python语言）——自底向上 <a class="header-anchor" href="#斐波那契数列——动态规划实现-python语言-——自底向上" aria-label="Permalink to &quot;斐波那契数列——动态规划实现（python语言）——自底向上&quot;">​</a></h2><p>动态规划——将需要重复计算的问题保存起来，不需要下次重新计算。对于斐波那契数列，算法复杂度为○(n)。</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">def</span><span style="color:#C3E88D;"> dp_fib</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">n</span><span style="color:#89DDFF;">)</span><span style="color:#C3E88D;">:</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    #初始化一个数组，用于存储记录计算的结果。</span></span>
<span class="line"><span style="color:#FFCB6B;">    res</span><span style="color:#C3E88D;"> =</span><span style="color:#BABED8;"> [None] </span><span style="color:#89DDFF;">*</span><span style="color:#BABED8;"> (</span><span style="color:#FFCB6B;">n</span><span style="color:#C3E88D;"> +</span><span style="color:#F78C6C;"> 1</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    #前两项设置为1。</span></span>
<span class="line"><span style="color:#FFCB6B;">    res[0]</span><span style="color:#C3E88D;"> =</span><span style="color:#C3E88D;"> res[1]</span><span style="color:#C3E88D;"> =</span><span style="color:#F78C6C;"> 1</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    #自底向上，将计算结果存入数组内。</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">    for</span><span style="color:#BABED8;"> i </span><span style="color:#89DDFF;font-style:italic;">in</span><span style="color:#C3E88D;"> range</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">2,</span><span style="color:#BABED8;"> (n </span><span style="color:#C3E88D;">+</span><span style="color:#F78C6C;"> 1</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;">):</span></span>
<span class="line"><span style="color:#FFCB6B;">        res[i]</span><span style="color:#C3E88D;"> =</span><span style="color:#C3E88D;"> res[i-1]</span><span style="color:#C3E88D;"> +</span><span style="color:#C3E88D;"> res[i-2]</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">    return</span><span style="color:#C3E88D;"> res[n]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="方法概要" tabindex="-1">方法概要 <a class="header-anchor" href="#方法概要" aria-label="Permalink to &quot;方法概要&quot;">​</a></h2><p>（1）构造一个公式，它表示一个问题的解是与它的子问题的解相关的公式：</p><p><img src="`+e+'" alt="An image"></p><p>（2）为这些子问题做索引，以便于它们能够在表中更好的存储与检索（用数组存储）。</p><p>（3）以自底向上的方法来填写这个表格；首先填写最小的子问题的解。</p><p>（4）这就保证了当我们解决一个特殊的子问题时，可以利用比它更小的所有可利用的子问题的解。</p><p>总之，因为在上世纪40年代（计算机普及很少时），这些规划设计是与“列表”方法相关的，因此被称为动态规划——Dynamic Programing</p>',15),r=[t];function c(i,y,D,b,d,F){return a(),n("div",null,r)}const h=s(o,[["render",c]]);export{m as __pageData,h as default};
