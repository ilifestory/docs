import{_ as e,c as a,o,a4 as t,bM as r}from"./chunks/framework.CCJHkvW2.js";const m=JSON.parse('{"title":"k8s理论","description":"","frontmatter":{},"headers":[],"relativePath":"deployment/k8s/k8s理论.md","filePath":"deployment/k8s/k8s理论.md","lastUpdated":1707190539000}'),l={name:"deployment/k8s/k8s理论.md"},d=t('<h1 id="k8s理论" tabindex="-1">k8s理论 <a class="header-anchor" href="#k8s理论" aria-label="Permalink to &quot;k8s理论&quot;">​</a></h1><h2 id="架构图" tabindex="-1">架构图 <a class="header-anchor" href="#架构图" aria-label="Permalink to &quot;架构图&quot;">​</a></h2><p><img src="'+r+'" alt="An image"></p><h2 id="物理组件" tabindex="-1">物理组件 <a class="header-anchor" href="#物理组件" aria-label="Permalink to &quot;物理组件&quot;">​</a></h2><h3 id="_1、master-主节点" tabindex="-1">1、Master(主节点) <a class="header-anchor" href="#_1、master-主节点" aria-label="Permalink to &quot;1、Master(主节点)&quot;">​</a></h3><p>Master 是 K8S 的集群控制节点，每个 K8S 集群里需要有一个 Master 节点来负责整个集群的管理和控制，基本上 K8S 所有的控制命令都是发给它，它来负责具体的执行过程。Master 节点通常会占据一个独立的服务器，因为它太重要了，如果它不可用，那么所有的控制命令都将失效。 Master 节点上运行着以下关键组件：</p><p>① kube-apiserver</p><p>是集群的统一入口，各组件协调者，以 HTTP Rest 提供接口服务，所有对象资源的增、删、改、查和监听操作都交给 apiserver 处理后再提交给 Etcd 存储。</p><p>② kube-controller-manager</p><p>是 K8S 里所有资源对象的自动化控制中心，处理集群中常规后台任务，一个资源对应一个控制器，而 controller-manager 就是负责管理这些控制器的。</p><p>Node Controller（节点控制器）：负责在节点出现故障时发现和响应。</p><p>Replication Controller（副本控制器）：负责保证集群中一个 RC（资源对象 Replication Controller）所关联的 Pod 副本数始终保持预设值。可以理解成确保集群中有且仅有 N 个 Pod 实例，N 是 RC 中定义的 Pod 副本数量。</p><p>Endpoints Controller（端点控制器）：填充端点对象（即连接 Services 和 Pods），负责监听 Service 和对应的 Pod 副本的变化。 可以理解端点是一个服务暴露出来的访问点，如果需要访问一个服务，则必须知道它的 endpoint。</p><p>Service Account &amp; Token Controllers（服务帐户和令牌控制器）：为新的命名空间创建默认帐户和 API 访问令牌。</p><p>ResourceQuota Controller（资源配额控制器）：确保指定的资源对象在任何时候都不会超量占用系统物理资源。</p><p>Namespace Controller（命名空间控制器）：管理 namespace 的生命周期。</p><p>Service Controller（服务控制器）：属于 K8S 集群与外部的云平台之间的一个接口控制器</p><p>③ kube-scheduler</p><p>根据调度算法为新创建的 Pod 选择一个 Node 节点，可以任意部署，可以部署在同一个节点上，也可以部署在不同的节点上。</p><p>是负责资源调度的进程，根据调度算法为新创建的 Pod 选择一个合适的 Node 节点。</p><p>可以理解成 K8S 所有 Node 节点的调度器。当用户要部署服务时，Scheduler 会根据调度算法选择最合适的 Node 节点来部署 Pod。</p><p>调度算法：</p><p>预选策略（predicate）</p><p>优选策略（priorities）</p><p>API Server 接收到请求创建一批 Pod ，API Server 会让 Controller-manager 按照所预设的模板去创建 Pod，Controller-manager 会通过 API Server 去找 Scheduler 为新创建的 Pod</p><p>选择最适合的 Node 节点。比如运行这个 Pod 需要 2C4G 的资源，Scheduler 会通过预选策略过滤掉不满足策略的 Node 节点。Node 节点中还剩多少资源是通过汇报给 API Server 存储在 etcd 里，</p><p>API Server 会调用一个方法找到 etcd 里所有 Node 节点的剩余资源，再对比 Pod 所需要的资源，如果某个 Node 节点的资源不足或者不满足 预选策略的条件则无法通过预选。预选阶段筛选出的节点，</p><p>在优选阶段会根据优选策略为通过预选的 Node 节点进行打分排名， 选择得分最高的 Node。例如，资源越富裕、负载越小的 Node 可能具有越高的排名。</p><p>④ etcd</p><p>是一个分布式的，一致的 key-value 存储，主要用途是共享配置和服务发现，保存集群状态数据，比如 Pod、Service 等对象信息。</p><h3 id="_2、node-工作节点" tabindex="-1">2、Node(工作节点) <a class="header-anchor" href="#_2、node-工作节点" aria-label="Permalink to &quot;2、Node(工作节点)&quot;">​</a></h3><p>除了 Master，K8S 集群中的其它机器被称为 Node 节点，Node 节点是 K8S 集群中的工作负载节点，每个 Node 都会被 Master 分配一些工作负载，当某个 Node 宕机时，其上的工作负载会被 Master 自动转移到其它节点上去。 每个 Node 节点上都运行着以下关键组件：</p><p>① kubelet</p><p>kubelet 是 Master 在 Node 节点上的 Agent(代理)，与 Master 密切协作，管理本机运行容器的生命周期，负责 Pod 对应的容器的创建、启停等任务，实现集群管理的基本功能。</p><p>② kube-proxy</p><p>在 Node 节点上实现 Pod 网络代理，实现 Kubernetes Service 的通信，维护网络规则和四层负载均衡工作。</p><p>③ docker engine</p><p>Docker 引擎，负责本机的容器创建和管理工作。 Node 节点可以在运行期间动态增加到 K8S 集群中，前提是这个节点上已经正确安装、配置和启动了上述关键组件。在默认情况下 kubelet 会向 Master 注册自己，一旦 Node 被纳入集群管理范围， kubelet 就会定时向 Master 节点汇报自身的情况，例如操作系统、Docker 版本、机器的 CPU 和内存情况，以及之前有哪些 Pod 在运行等，这样 Master 可以获知每个 Node 的资源使用情况， 并实现高效均衡的资源调度策略。而某个 Node 超过指定时间不上报信息时，会被 Master 判定为“失联”，Node 的状态被标记为不可用（Not Ready），随后 Master 会触发“工作负载大转移”的自动流程。</p><h2 id="逻辑组件-概念" tabindex="-1">逻辑组件(概念) <a class="header-anchor" href="#逻辑组件-概念" aria-label="Permalink to &quot;逻辑组件(概念)&quot;">​</a></h2><h3 id="_1、pod" tabindex="-1">1、Pod <a class="header-anchor" href="#_1、pod" aria-label="Permalink to &quot;1、Pod&quot;">​</a></h3><p>Pod 是 K8S 中最重要也是最基本的概念，Pod 是最小的部署单元，是一组容器的集合。每个 Pod 都由一个特殊的根容器 Pause 容器，以及一个或多个紧密相关的用户业务容器组成。 Pause 容器作为 Pod 的根容器，以它的状态代表整个容器组的状态。K8S 为每个 Pod 都分配了唯一的 IP 地址，称之为 Pod IP。Pod 里的多个业务容器共享 Pause 容器的IP，共享 Pause 容器挂载的 Volume。</p><h3 id="_2、label" tabindex="-1">2、Label <a class="header-anchor" href="#_2、label" aria-label="Permalink to &quot;2、Label&quot;">​</a></h3><p>标签，附加到某个资源上，用于关联对象、查询和筛选。一个 Label 是一个 key=value 的键值对，key 与 value 由用户自己指定。Label 可以附加到各种资源上，一个资源对象可以定义任意数量的 Label， 同一个 Label 也可以被添加到任意数量的资源上。 我们可以通过给指定的资源对象捆绑一个或多个不同的 Label 来实现多维度的资源分组管理功能，以便于灵活、方便地进行资源分配、调度、配置、部署等工作。 K8S 通过 Label Selector（标签选择器）来查询和筛选拥有某些 Label 的资源对象。Label Selector 有基于等式（ name=label1 ）和基于集合（ name in (label1, label2) ）的两种方式。</p><h3 id="_3、replicaset-rs" tabindex="-1">3、ReplicaSet（RS） <a class="header-anchor" href="#_3、replicaset-rs" aria-label="Permalink to &quot;3、ReplicaSet（RS）&quot;">​</a></h3><p>副本控制器（Replication Controller，RC） RC是Kubernetes集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动运行新的Pod副本；多于指定数目， RC就会杀死多余的Pod副本。即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证永远有1个Pod在运行。RC是Kubernetes较早期的技术概念，只适用于长期伺服型的业务类型， 比如控制小机器人提供高可用的Web服务。</p><p>ReplicaSet 用来确保预期的 Pod 副本数量，如果有过多的 Pod 副本在运行，系统就会停掉一些 Pod，否则系统就会再自动创建一些 Pod。 我们很少单独使用 ReplicaSet，它主要被 Deployment 这个更高层的资源对象使用，从而形成一整套 Pod 创建、删除、更新的编排机制。</p><h3 id="_4、deployment" tabindex="-1">4、Deployment <a class="header-anchor" href="#_4、deployment" aria-label="Permalink to &quot;4、Deployment&quot;">​</a></h3><p>Deployment 用于部署无状态应用，Deployment 为 Pod 和 ReplicaSet 提供声明式更新，只需要在 Deployment 描述想要的目标状态，Deployment 就会将 Pod 和 ReplicaSet 的实际状态改变到目标状态。</p><h3 id="_5、horizontal-pod-autoscaler-hpa" tabindex="-1">5、Horizontal Pod Autoscaler（HPA） <a class="header-anchor" href="#_5、horizontal-pod-autoscaler-hpa" aria-label="Permalink to &quot;5、Horizontal Pod Autoscaler（HPA）&quot;">​</a></h3><p>HPA 为 Pod 横向自动扩容，也是 K8S 的一种资源对象。HPA 通过追踪分析 RC 的所有目标 Pod 的负载变化情况，来确定是否需要针对性调整目标 Pod 的副本数量。</p><h3 id="_6、service" tabindex="-1">6、Service <a class="header-anchor" href="#_6、service" aria-label="Permalink to &quot;6、Service&quot;">​</a></h3><p>Service 定义了一个服务的访问入口，通过 Label Selector 与 Pod 副本集群之间“无缝对接”，定义了一组 Pod 的访问策略，防止 Pod 失联。 创建 Service 时，K8S会自动为它分配一个全局唯一的虚拟 IP 地址，即 Cluster IP。服务发现就是通过 Service 的 Name 和 Service 的 ClusterIP 地址做一个 DNS 域名映射来解决的。</p><h2 id="_7、statefulset-有状态服务集" tabindex="-1">7、StatefulSet 有状态服务集 <a class="header-anchor" href="#_7、statefulset-有状态服务集" aria-label="Permalink to &quot;7、StatefulSet 有状态服务集&quot;">​</a></h2><p>Kubernetes在1.3版本里发布了Alpha版的PetSet功能，在1.5版本里将PetSet功能升级到了Beta版本，并重新命名为StatefulSet，最终在1.9版本里成为正式GA版本。 在云原生应用的体系里，有下面两组近义词；第一组是无状态（stateless）、牲畜（cattle）、无名（nameless）、可丢弃（disposable）；第二组是有状态（stateful）、 宠物（pet）、有名（having name）、不可丢弃（non-disposable）。RC和RS主要是控制提供无状态服务的，其所控制的Pod的名字是随机设置的，一个Pod出故障了就被丢弃掉， 在另一个地方重启一个新的Pod，名字变了。名字和启动在哪儿都不重要，重要的只是Pod总数；而StatefulSet是用来控制有状态服务，StatefulSet中的每个Pod的名字都是事先确定的， 不能更改。StatefulSet中Pod的名字的作用，并不是《千与千寻》的人性原因，而是关联与该Pod对应的状态。 对于RC和RS中的Pod，一般不挂载存储或者挂载共享存储，保存的是所有Pod共享的状态，Pod像牲畜一样没有分别（这似乎也确实意味着失去了人性特征）；对于StatefulSet中的Pod， 每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来Pod的存储继续以它的状态提供服务。 适合于StatefulSet的业务包括数据库服务MySQL和PostgreSQL，集群化管理服务ZooKeeper、etcd等有状态服务。StatefulSet的另一种典型应用场景是作为一种比普通容器更稳定可靠的模拟虚拟机的机制。 传统的虚拟机正是一种有状态的宠物，运维人员需要不断地维护它，容器刚开始流行时，我们用容器来模拟虚拟机使用，所有状态都保存在容器里，而这已被证明是非常不安全、不可靠的。使用StatefulSet， Pod仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，StatefulSet做的只是将确定的Pod与确定的存储关联起来保证状态的连续性。</p><h2 id="_8、daemonset-后台支撑服务集" tabindex="-1">8、DaemonSet 后台支撑服务集 <a class="header-anchor" href="#_8、daemonset-后台支撑服务集" aria-label="Permalink to &quot;8、DaemonSet 后台支撑服务集&quot;">​</a></h2><p>长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些节点上又没有这类Pod运行；而后台支撑型服务的核心关注点在Kubernetes集群中的节点（物理机或虚拟机）， 要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点也可能是通过nodeSelector选定的一些特定节点。典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支持Kubernetes集群运行的服务。</p><h3 id="_9、namespace" tabindex="-1">9、Namespace <a class="header-anchor" href="#_9、namespace" aria-label="Permalink to &quot;9、Namespace&quot;">​</a></h3><p>命名空间，Namespace 多用于实现多租户的资源隔离。Namespace 通过将集群内部的资源对象“分配”到不同的Namespace中，形成逻辑上分组的不同项目、小组或用户组。 K8S 集群在启动后，会创建一个名为 default 的 Namespace，如果不特别指明 Namespace，创建的 Pod、RC、Service 都将被创建到 default 下。 当我们给每个租户创建一个 Namespace 来实现多租户的资源隔离时，还可以结合 K8S 的资源配额管理，限定不同租户能占用的资源，例如 CPU 使用量、内存使用量等。</p><h2 id="_10、secret密钥对象" tabindex="-1">10、Secret密钥对象 <a class="header-anchor" href="#_10、secret密钥对象" aria-label="Permalink to &quot;10、Secret密钥对象&quot;">​</a></h2><p>Secret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。使用Secret的好处是可以避免把敏感信息明文写在配置文件里。在Kubernetes集群中配置和使用服务不可避免的要用到各种敏感信息实现登录、 认证等功能，例如访问AWS存储的用户名密码。为了避免将类似的敏感信息明文写在所有需要使用的配置文件中，可以将这些信息存入一个Secret对象，而在配置文件中通过Secret对象引用这些敏感信息。 这种方式的好处包括：意图明确，避免重复，减少暴漏机会。</p>',60),p=[d];function s(n,i,c,P,h,S){return o(),a("div",null,p)}const b=e(l,[["render",s]]);export{m as __pageData,b as default};
