import{_ as a,c as e,o as t,a4 as p}from"./chunks/framework.CCJHkvW2.js";const m=JSON.parse('{"title":"动态规划算法","description":"","frontmatter":{},"headers":[],"relativePath":"算法与程序设计/dp算法/README.md","filePath":"算法与程序设计/dp算法/README.md","lastUpdated":1708482714000}'),r={name:"算法与程序设计/dp算法/README.md"},o=p('<h1 id="动态规划算法" tabindex="-1">动态规划算法 <a class="header-anchor" href="#动态规划算法" aria-label="Permalink to &quot;动态规划算法&quot;">​</a></h1><h2 id="dp算法思想" tabindex="-1">DP算法思想 <a class="header-anchor" href="#dp算法思想" aria-label="Permalink to &quot;DP算法思想&quot;">​</a></h2><p>（1）将待求解的问题分解称若干个子问题，并存储子问题的解而避免计算重复的子问题，并由子问题的解得到原问题的解。</p><p>（2）动态规划算法通常用于求解具有某种最有性质的问题。</p><p>（3）动态规划算法的基本要素：最优子结构性质和重叠子问题。</p><p>最优子结构性质：问题的最优解包含着它的子问题的最优解。即不管前面的策略如何，此后的决策必须是基于当前状态（由上一次的决策产生）的最优决策。</p><p>重叠子问题：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些问题被反复计算多次。对每个子问题只解一次，然后将其解保存起来，</p><p>以后再遇到同样的问题时就可以直接引用，不必重新求解。</p><h2 id="dp算法——解决问题的基本特征" tabindex="-1">DP算法——解决问题的基本特征 <a class="header-anchor" href="#dp算法——解决问题的基本特征" aria-label="Permalink to &quot;DP算法——解决问题的基本特征&quot;">​</a></h2><p>（1）动态规划一般求解最值（最优、最大、最小、最长）问题；</p><p>（2）动态规划解决 的问题一般是离散的，可以分解的（划分阶段的）。</p><p>（3）动态规划结局的问题必须包含最优子结构，即可以有（n-1）的最优推导出n的最优。</p><h2 id="dp算法——解决问题的基本步骤" tabindex="-1">DP算法——解决问题的基本步骤 <a class="header-anchor" href="#dp算法——解决问题的基本步骤" aria-label="Permalink to &quot;DP算法——解决问题的基本步骤&quot;">​</a></h2><p>动态规划算法的四个步骤：</p><p>（1）刻画最优解的结构特性。（一维、二维、三维数组）；</p><p>（2）递归的定义最优解。（状态转移方程）</p><p>（3）以自底向上的方法来计算最优解。</p><p>（4）从计算得到的解来构造一个最优解。</p>',18),d=[o];function n(s,i,c,_,h,l){return t(),e("div",null,d)}const u=a(r,[["render",n]]);export{m as __pageData,u as default};
