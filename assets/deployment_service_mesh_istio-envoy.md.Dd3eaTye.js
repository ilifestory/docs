import{_ as e,c as s,o as a,a4 as o,bO as n,bP as p,bQ as l,bR as t,bS as r,bT as i,bU as c,bV as d,bW as y}from"./chunks/framework.CCJHkvW2.js";const _=JSON.parse('{"title":"Istio组件Envoy、Pilot","description":"","frontmatter":{},"headers":[],"relativePath":"deployment/service_mesh/istio-envoy.md","filePath":"deployment/service_mesh/istio-envoy.md","lastUpdated":null}'),h={name:"deployment/service_mesh/istio-envoy.md"},E=o('<h1 id="istio组件envoy、pilot" tabindex="-1">Istio组件Envoy、Pilot <a class="header-anchor" href="#istio组件envoy、pilot" aria-label="Permalink to &quot;Istio组件Envoy、Pilot&quot;">​</a></h1><p>参考文献(<a href="https://www.51cto.com/article/708490.html" target="_blank" rel="noreferrer">https://www.51cto.com/article/708490.html</a>)(<a href="https://blog.csdn.net/xianmingsu/article/details/135813459" target="_blank" rel="noreferrer">https://blog.csdn.net/xianmingsu/article/details/135813459</a>)(<a href="https://www.cnblogs.com/muzinan110/p/17133121.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/muzinan110/p/17133121.html</a>)</p><p>Istio的控制面组件Pilot、数据面组件Envoy</p><p>Envoy中的xDS模块的功能是通过 Envoy API V1（基于HTTP）或 Envoy API V2（基于gRPC）实现一个服务端将配置信息暴露给上游主机，等待上游主机的Pilot拉取。</p><h2 id="envoy的流量管理" tabindex="-1">Envoy的流量管理 <a class="header-anchor" href="#envoy的流量管理" aria-label="Permalink to &quot;Envoy的流量管理&quot;">​</a></h2><h2 id="背景介绍" tabindex="-1">背景介绍 <a class="header-anchor" href="#背景介绍" aria-label="Permalink to &quot;背景介绍&quot;">​</a></h2><p>微服务架构带来的开发便捷性使业务功能的开发周期明显缩短，通过对于云计算平台架构的原生优化，让业务功能的持续集成与交付更为敏捷。但同时微服务架构也引入了服务治理的诸多问题： 一个应用由多个服务组成，每个服务有数个实例，每个实例的运行状态又在实时变化，这些催生了服务间通讯层的出现。通讯层既不与应用程序代码耦合，又能捕获到底层环境的动态变化并作出适当的调整， 避免业务出现单点故障。</p><h2 id="_1-servicemesh简介" tabindex="-1">1.ServiceMesh简介 <a class="header-anchor" href="#_1-servicemesh简介" aria-label="Permalink to &quot;1.ServiceMesh简介&quot;">​</a></h2><h3 id="_1-1服务网格-service-mesh-简介" tabindex="-1">1.1服务网格(Service Mesh)简介 <a class="header-anchor" href="#_1-1服务网格-service-mesh-简介" aria-label="Permalink to &quot;1.1服务网格(Service Mesh)简介&quot;">​</a></h3><p>服务网络是一个基础设施层，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格负责在这些拓扑中实现请求的可靠传递。在实践中，服务网格通常实现为一组轻量级网络代理， 它们与应用程序一起部署，但对应用程序透明。</p><p><img src="'+n+'" alt="An image"></p><p>从局部看，服务网格技术就是在应用节点上部署代理，应用将请求发给代理，由代理完成点对点的路由转发。</p><p><img src="'+p+'" alt="An image"></p><p>在上面的图中，如果把左边图中的应用程序去掉，只呈现出来代理和它们之间的调用关系(即右图)。这时Service Mesh的概念就会清晰：代理和调用关系形成完整的网络， 代表服务间复杂的调用关系，承载着系统内的所有应用。</p><h3 id="_1-2服务网络架构特点及优势" tabindex="-1">1.2服务网络架构特点及优势 <a class="header-anchor" href="#_1-2服务网络架构特点及优势" aria-label="Permalink to &quot;1.2服务网络架构特点及优势&quot;">​</a></h3><p>1）点对点通讯：没有中心瓶颈。</p><p>2）对应用无入侵：可以支持异构技术产品的集成。同时对应用透明，应用开发不再需要关心复杂的网络通讯实现，可以专注业务逻辑的实现。</p><p><img src="'+l+'" alt="An image"></p><h2 id="_2-istio及envoy简介" tabindex="-1">2.Istio及Envoy简介 <a class="header-anchor" href="#_2-istio及envoy简介" aria-label="Permalink to &quot;2.Istio及Envoy简介&quot;">​</a></h2><p>Istio是一个由Google，IBM和Lyft团队合作开发的开源Service Mesh框架。目前已成为ServiceMesh的事实技术标准，被广泛应用于各个行业的IT架构。</p><p><img src="'+t+'" alt="An image"></p><p>Envoy 是用 C++语言开发的高性能代理，其内置服务发现、负载均衡、TLS终止、HTTP/2、GRPC代理、熔断器、健康检查，基于百分比流量拆分的灰度发布、故障注入等功能， 用于协调服务网格中所有服务的入站和出站流量。</p><h2 id="_3-envoy流量管理的原理" tabindex="-1">3.Envoy流量管理的原理 <a class="header-anchor" href="#_3-envoy流量管理的原理" aria-label="Permalink to &quot;3.Envoy流量管理的原理&quot;">​</a></h2><h3 id="_3-1-iptables介绍" tabindex="-1">3.1 Iptables介绍 <a class="header-anchor" href="#_3-1-iptables介绍" aria-label="Permalink to &quot;3.1 Iptables介绍&quot;">​</a></h3><p>Istio调用Linux中的iptables进行流量管理。iptables是一个运行在用户空间的应用软件，它通过控制Linux内核netfilter模块，来管理网络数据包的流动与转送， 实际上netfilter才是防火墙真正的安全框架。netfilter是Linux网络安全大厦的基石，它提供了一整套钩子(Hook)函数机制，IP层的5个钩子点对应了iptables的5个内置链条：</p><p><code>PREROUTING</code>：在此DNAT。</p><p><code>POSTROUTING</code>：在此SNAT。</p><p><code>INPUT</code>：处理输入给本地进程的封包。</p><p><code>OUTPUT</code>：处理本地进程输出的封包。</p><p><code>FORWARD</code>：处理转发给其他机器、其他网络命名空间的封包。</p><h3 id="_3-2-关于网络入站的ip封包" tabindex="-1">3.2 关于网络入站的IP封包 <a class="header-anchor" href="#_3-2-关于网络入站的ip封包" aria-label="Permalink to &quot;3.2 关于网络入站的IP封包&quot;">​</a></h3><p>从网络入站的IP封包，先入<code>TREOUTING</code>链，而后进行路由判断：</p><p>1）如果封包路由目的地是本机：则进入<code>INPUT</code>链，然后发给本地进程。</p><p>2）如果封包路由目的地不是本机，并且启用了IP转发，则进入<code>FORWARD</code>链，然后通过<code>POSTROUTING</code>链，最后经过网网络接口发走。</p><p>3）对于本地进程发往协议栈的封包，则首先通过<code>OUTPUT</code>链，然后通过<code>POSTROUTING</code>链，最后经过网络接口发走。</p><h3 id="_3-3-关于自定义链" tabindex="-1">3.3 关于自定义链 <a class="header-anchor" href="#_3-3-关于自定义链" aria-label="Permalink to &quot;3.3 关于自定义链&quot;">​</a></h3><p>除此以外，我们还可以自定义链，但自定义链只能被某个默认的链当做动作去调用才能起作用。</p><p>在Kubernetes中Istio通过Admission webhook的机制将Envoy Sidecar自动注入，与应用容器运行于同一个Pod中，这种情况下它们将共享网络名称空间，因此也使用同一个网络协议栈。</p><p>Istio 给应用 Pod 注入的配置主要包括：</p><p>1）Init 容器 istio-init：用于Pod中设置iptables端口转发。</p><p>2）Sidecar 容器 istio-proxy：运行Envoy Sidecar代理。</p><h3 id="_3-4-iptables配置规则" tabindex="-1">3.4 Iptables配置规则 <a class="header-anchor" href="#_3-4-iptables配置规则" aria-label="Permalink to &quot;3.4 Iptables配置规则&quot;">​</a></h3><p>在容器初始化后，我们进入Sidecar容器切换为root用户，查看配置的iptables规则。</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">iptables</span><span style="color:#C3E88D;"> -t</span><span style="color:#C3E88D;"> nat</span><span style="color:#C3E88D;"> -S</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="'+r+'" alt="An image"></p><p><code>ISTIO_INBOUND</code> 链：对所有进入Pod但非指定端口(如22)的流量全部重定向至15006端口(Envoy入口流量端口)进行拦截处理。</p><p><code>ISTIO_OUTPUT</code> 链：将由 istio-proxy 用户空间发出且目的地不为localhost的Pod流出流量全部重定向至15001端口(envoy出口流量端口)。其他流量全部直接放行至下一个<code>POSTROUTING</code>链，</p><p>不用被Envoy拦截处理。</p><p>整体流量流向示意图如下图所示:</p><div class="tip custom-block"><p class="custom-block-title">以用户请求下单-&gt;订单服务-&gt;支付服务为例</p><p>步骤1: 将调用订单服务</p><p>App服务: 订单服务</p><p>步骤16: 将调用支付服务</p><p><img src="'+i+'" alt="An image"></p></div><p>1）进入Pod的<code>Inbound</code>流量首先被<code>PREROUTING</code>链拦截并处理。</p><p>2）当TCP请求进入<code>PREROUTING</code>链时全部交给<code>ISTIO_INBOUND</code>处理。</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-A</span><span style="color:#C3E88D;"> PREROUTING</span><span style="color:#C3E88D;"> -p</span><span style="color:#C3E88D;"> tcp</span><span style="color:#C3E88D;"> -j</span><span style="color:#C3E88D;"> ISTIO_INBOUND</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>3）请求目标端口非15008/22/15090/15021/15020的TCP请求全部交给<code>ISTIO_IN_REDIRECT</code>处理。</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-A</span><span style="color:#C3E88D;"> ISTIO_INBOUND</span><span style="color:#C3E88D;"> -p</span><span style="color:#C3E88D;"> tcp</span><span style="color:#C3E88D;"> -j</span><span style="color:#C3E88D;"> ISTIO_IN_REDIRECT</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>4）将发送到此的TCP请求全部重定向至15006端口(Envoy入口流量端口)</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-A</span><span style="color:#C3E88D;"> ISTIO_IN_REDIRECT</span><span style="color:#C3E88D;"> -p</span><span style="color:#C3E88D;"> tcp</span><span style="color:#C3E88D;"> -j</span><span style="color:#C3E88D;"> REDIRECT</span><span style="color:#C3E88D;"> --to-ports</span><span style="color:#F78C6C;"> 15006</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>5）在Envoy内部处理后，决定将数据包转发到应用(订单服务)，这一步对Envoy(代理服务)来说属于出口流量，会被netfilter拦截转发至出口流量<code>OUTPUT</code>链。</p><p>6）出站请求，当TCP请求进入<code>OUTPUT</code>链时全部交给<code>ISTIO_OUTPUT</code>处理。</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-A</span><span style="color:#C3E88D;"> OUTPUT</span><span style="color:#C3E88D;"> -p</span><span style="color:#C3E88D;"> tcp</span><span style="color:#C3E88D;"> -j</span><span style="color:#C3E88D;"> ISTIO_OUTPUT</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>7）匹配出站请求对应规则，请求本地服务，出口为lo网卡同时来自istio-proxy用户空间，流量返回到它的调用点中的下一条链执行，即<code>POSTROUTING</code>链 。</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-A</span><span style="color:#C3E88D;"> ISTIO_OUTPUT</span><span style="color:#C3E88D;"> -m</span><span style="color:#C3E88D;"> owner</span><span style="color:#C3E88D;"> --uid-owner</span><span style="color:#F78C6C;"> 1337</span><span style="color:#C3E88D;"> -j</span><span style="color:#C3E88D;"> RETURN</span><span style="color:#C3E88D;"> -A</span><span style="color:#C3E88D;"> ISTIO_OUTPUT</span><span style="color:#C3E88D;"> -m</span><span style="color:#C3E88D;"> owner</span><span style="color:#C3E88D;"> --gid-owner</span><span style="color:#F78C6C;"> 1337</span><span style="color:#C3E88D;"> -j</span><span style="color:#C3E88D;"> RETURN</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>8）Sidecar发出的请求到达目标应用。</p><p>9）目标应用处理完业务逻辑后响应Sidecar，这一步对应用(订单服务调用支付服务)来说属于出口流量，再次被netfilter拦截转发至出口流量<code>OUTPUT</code>链。</p><p>10） 出站请求，当TCP请求进入<code>OUTPUT</code>链时全部交给<code>ISTIO_OUTPUT</code>处理。</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-A</span><span style="color:#C3E88D;"> OUTPUT</span><span style="color:#C3E88D;"> -p</span><span style="color:#C3E88D;"> tcp</span><span style="color:#C3E88D;"> -j</span><span style="color:#C3E88D;"> ISTIO_OUTPUT</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>11）请求下一个服务(支付服务/响应请求)，即请求非本地服务(源:订单服务 target: 支付服务)同时不来自istio-proxy(Envoy代理服务)用户空间(本地的订单服务)，流量被转发至<code>ISTIO_REDIRECT</code>链。</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-A</span><span style="color:#C3E88D;"> ISTIO_OUTPUT</span><span style="color:#C3E88D;"> -j</span><span style="color:#C3E88D;"> ISTIO_REDIRECT</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>12）将重定向于此的TCP协议请求流量全部重定向至15001端口(Envoy出口流量端口)。</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-A</span><span style="color:#C3E88D;"> ISTIO_REDIRECT</span><span style="color:#C3E88D;"> -p</span><span style="color:#C3E88D;"> tcp</span><span style="color:#C3E88D;"> -j</span><span style="color:#C3E88D;"> REDIRECT</span><span style="color:#C3E88D;"> --to-ports</span><span style="color:#F78C6C;"> 15001</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>13）在Envoy内部处理后，决定将数据包对外转发，这一步对Envoy来说属于出口流量，会被netfilter拦截转发至出口流量<code>OUTPUT</code>链。</p><p>14）出站请求，当TCP请求进入<code>OUTPUT</code>链时全部交给<code>ISTIO_OUTPUT</code>处理。</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-A</span><span style="color:#C3E88D;"> OUTPUT</span><span style="color:#C3E88D;"> -p</span><span style="color:#C3E88D;"> tcp</span><span style="color:#C3E88D;"> -j</span><span style="color:#C3E88D;"> ISTIO_OUTPUT</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>15）请求非本地的服务，出口不为lo网卡同时来自istio-proxy用户空间则跳过了<code>ISTIO_REDIREC</code>处理，直接RETURN到下一个链，即<code>POSTROUTING</code>链</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">-A</span><span style="color:#C3E88D;"> ISTIO_OUTPUT</span><span style="color:#C3E88D;"> -m</span><span style="color:#C3E88D;"> owner</span><span style="color:#C3E88D;"> --uid-owner</span><span style="color:#F78C6C;"> 1337</span><span style="color:#C3E88D;"> -j</span><span style="color:#C3E88D;"> RETURN</span><span style="color:#C3E88D;"> -A</span><span style="color:#C3E88D;"> ISTIO_OUTPUT</span><span style="color:#C3E88D;"> -m</span><span style="color:#C3E88D;"> owner</span><span style="color:#C3E88D;"> --gid-owner</span><span style="color:#F78C6C;"> 1337</span><span style="color:#C3E88D;"> -j</span><span style="color:#C3E88D;"> RETURN</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>16）<code>POSTROUTING</code>链处理完成后，根据路由表选择合适的网卡发送<code>Outbound</code>流量。</p><h2 id="_4-总结" tabindex="-1">4.总结 <a class="header-anchor" href="#_4-总结" aria-label="Permalink to &quot;4.总结&quot;">​</a></h2><p>Envoy的核心工作内容在于对业务透明的请求拦截，将所有进出流量进行管理。对拦截的请求进行一定的规则进行安全访问控制、接入控制、流量控制等诸多方面处理后， 发送给应用程序。通过使用Envoy，可以使开发者专注于应用功能的开发，不用考虑复杂的网络通讯。</p><p><img src="'+c+'" alt="An image"></p><p>分两部分来总结，首先是Istio(Pilot组件) 与 Envoy的交互过程。</p><p>1）Pilot使用client-go的Informer组件连接API Server获取集群中所有服务的Service和对应的Endpoints信息，这样就完成了服务的发现。</p><p>2）Pilot也会从API Server中获取用户自定义的VirtualService、DestinationRule等Istio的CRD资源对象。这样就获取了用户自定义的服务治理策略。</p><p>3）Pilot将服务的Endpoints信息和服务治理策略转化成Envoy能够识别的格式，并下发给Envoy代理。</p><p>通过上面的流程，Istio的控制面组件Pilot、数据面组件Envoy和Kubernetes是如何一起工作的。</p><p>接下来分析图中一个下游客户端的请求到达Envoy后是如何被处理的，在这之前先了解Envoy的4种核心资源。</p><p>1.Listener</p><p>Listener是Envoy打开的一个端口，用来接受客户端发起的请求。多个Listener之间是相互隔离的。Listener除了监听端口以外还会配置L3或L4的过滤器。它的配置使用xDS（Envoy动态获取配置的传输协议，是一类发现服务的总称）中的LDS（Listener Discovery Service，监听器发现服务）。</p><p>2.Cluster</p><p>Cluster是对上游服务的抽象，每个上游服务都被抽象为一个Cluster。Cluster的配置主要有超时时间、连接池、Endpoints等信息。它的配置使用xDS中的CDS（Cluster Discovery Service，集群发现服务）和EDS（Endpoint Discovery Service，端点发现服务）。</p><p>3.Route</p><p>上下游之间的桥梁，Listener负责监听并接收来自下游客户端的请求，Cluster负责将流量转发给具体的上游服务。而Route则决定了Listener接收到的流量要发送给下游的哪个Cluster。它定义了数据的分发规则并负责Virtual Host（虚拟主机）的定义，也负责HTTP头的增加、删除、更改等。此外它也负责超时重试。它的配置使用xDS中的RDS（Route Discovery Service，路由发现服务）。</p><p>4.Filter</p><p>在Istio中习惯叫它Envoy Filter。它类似一个插件机制，让用户可以在不侵入源码的基础上对Envoy做各个方面的增强。Envoy通过它获得了强大的扩展能力，理论上Envoy利用Filter的机制可以实现任何协议的支持以及协议之间的转换，可以实现对流量的全方位定制和修改。</p><p>·监听过滤器（Listener Filter）主要负责将数据交给L3/L4的网络过滤器。</p><p>·网络过滤器（Network Filter）主要负责网络连接的处理，工作在L3/L4。图中展示了目前Envoy支持的网络过滤器。目前有些Envoy Filter还不成熟。</p><p>·HTTP过滤器主要负责HTTP流量的处理，在图中我们可以看到，HTTP过滤器是由特殊的网络过滤器HTTP Connection Manager管理的。</p><p><img src="'+d+'" alt="An image"></p><p>Main Thread通过XDS API(Pilot 调用此API)接收控制平面下发的配置，然后将listener、route_config、cluster等各配置项下发至Worker Thread，Worker Thread负责真正接收处理请求流量。 这里 Main Thread可以看成控制平面，Work Thread看成数据平面，上图右侧是Pilot发送的API请求入Envoy</p><p><img src="'+y+'" alt="An image"></p><p>基于Istio的流量治理，控制平面是其istiod组件，而这个proxy角色就是反向代理软件Envoy。istiod负责生成并下发Envoy的配置。通过丰富的路由规则，对流量行为进行细粒度的控制。</p>',100),m=[E];function C(v,T,b,u,I,D){return a(),s("div",null,m)}const g=e(h,[["render",C]]);export{_ as __pageData,g as default};
